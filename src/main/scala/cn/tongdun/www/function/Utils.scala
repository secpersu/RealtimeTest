package cn.tongdun.www.function

/**
 * Created by wangqiaoshi on 15/8/26.
 */

import java.io.{File, FileInputStream}

import cn.tongdun.www.function.Enums._

import java.util.Properties
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.scala.DefaultScalaModule
import net.minidev.json.parser.JSONParser
import net.minidev.json.{JSONObject, JSONValue}


import scala.collection.JavaConverters._
import scala.collection.convert.Wrappers.{JListWrapper, JMapWrapper}
import scala.collection.{immutable, Map, mutable}
import scala.io.Source
import scala.collection.JavaConversions._

object Utils {
  val cassandraIp="192.168.6.55"
  val zooKeeperIps="192.168.6.55,192.168.6.56,192.168.6.57"
//  val jsonParser =new JSONParser()
  val jsonObj = new JSONObject();


  def loadPropertie(path:String): mutable.Map[String,String] ={
    val properties=new Properties()
    properties.load(new FileInputStream(path))
    properties.asScala
  }

  //ComputeTypes 由字符串转化成枚举类型
  def computeTypeConvert(computeType:String): ComputeTypes.Value ={
    if(computeType.equals("distinctcount")){
      ComputeTypes.distinctCount
    }

    else{
      ComputeTypes.distinctCount
    }
  }

  //将map convert json string
  import scala.collection.immutable
  implicit val formats = net.liftweb.json.DefaultFormats
  import net.liftweb.json._
  def mapToJsonstr(map: immutable.Map[String,Any]): String ={

     compact(JsonAST.render(Extraction.decompose(map)))
  }


  def jsonstrToMap(jsonStr:String): mutable.Map[String,String] ={
    val jsonParser =new JSONParser()
    val json =  mapAsScalaMap(jsonParser.parse(jsonStr).asInstanceOf[java.util.HashMap[String,String]])
    json
//    val hashMap=JsonParser.parse(jsonStr).values.asInstanceOf[immutable.Map[String,String]]
//    hashMap
  }

  def jsonstrToFloatMap(jsonStr:String): immutable.Map[Float,String] ={

    val hashMap=JsonParser.parse(jsonStr).values.asInstanceOf[immutable.Map[Float,String]]
    hashMap
  }




//  def parseToPolicyAndData(jsonStr:String):mutable.MutableList[(String,immutable.Map[String,String])] ={
////    val beginTime=System.nanoTime()
//    val resultList=new mutable.MutableList[(String,immutable.Map[String,String])]()
//    val hashMap=JsonParser.parse(jsonStr).values.asInstanceOf[immutable.Map[String,Any]]
//
////    val endTime=System.nanoTime()
////    println("single time is "+(endTime-beginTime))
//
//    val policys=hashMap.getOrElse("policys","[]").asInstanceOf[immutable.List[String]]
//    val datas=hashMap.getOrElse("datas","{}").asInstanceOf[immutable.Map[String,String]]
//
//    for(policy<-policys){
//      val Array(priAttrFieldName,computeFieldName,computeType,outRange)=policy.split(":")
//
//      datas.get(priAttrFieldName) match {
//        case None=>
//
//        case Some(priAttrFieldValue)=>
//
//          resultList.+=((policy+","+priAttrFieldValue,datas))
//      }
//    }
//
//    resultList
//
//  }


  def parseToPolicyAndDataV2(jsonStrs:Iterator[(String,String)]): Iterator[(String,mutable.Map[String,String])] = {


    val resultList=new mutable.MutableList[(String,mutable.Map[String,String])]()
    val jsonParser =new JSONParser()
    jsonStrs.flatMap{r=>
      val json: JSONObject = jsonParser.parse(r._2).asInstanceOf[JSONObject]

      val datas = mapAsScalaMap(json.get("datas").asInstanceOf[java.util.HashMap[String, String]])
      val policys = asScalaBuffer(json.get("policys").asInstanceOf[java.util.List[String]])
      resultList.clear()
      for (policy <- policys) {
        val Array(priAttrFieldName, computeFieldName, computeType, outRange) = policy.split(":")

        datas.get(priAttrFieldName) match {
          case None =>

          case Some(priAttrFieldValue) =>
            val outMap = mutable.Map[String, String]()
            outMap.put("time", datas.get("time").get)
            outMap.put(computeFieldName, datas.get(computeFieldName).get)
            resultList.+=((policy + "," + priAttrFieldValue, outMap))

        }
      }
      resultList
    }
  }

   def scalafy(obj: Any): Any = obj match {
    case map: java.util.Map[_, _] =>
      // .map(identity) is used as a workaround of non-serializable Map
      // generated by .mapValues.
      // This issue is documented at https://issues.scala-lang.org/browse/SI-7005
      JMapWrapper(map).mapValues(scalafy).map(identity)
    case list: java.util.List[_] =>
      JListWrapper(list).map(scalafy)
    case atom => atom
  }
//  def parseToPolicyAndDataV3(jsonStrs:Iterator[String]): Iterator[(String,immutable.Map[String,String])] ={
//
//    val resultList=new mutable.MutableList[(String,mutable.Map[String,String])]()
//
//    val jsonParser =new JSONParser()
//    val json : JSONObject =  jsonParser.parse(jsonData).asInstanceOf[JSONObject]
//
//    val datas=mapAsScalaMap(json.get("datas").asInstanceOf[java.util.HashMap[String,String]])
//    val policys= asScalaBuffer(json.get("policys").asInstanceOf[java.util.List[String]])
//
//    for(policy<-policys){
//      val Array(priAttrFieldName,computeFieldName,computeType,outRange)=policy.split(":")
//
//      datas.get(priAttrFieldName) match {
//        case None=>
//
//        case Some(priAttrFieldValue)=>
//          val outMap=mutable.Map[String,String]()
//          outMap.put("time",datas.get("time").get)
//          outMap.put(computeFieldName,datas.get(computeFieldName).get)
//          resultList.+=((policy+","+priAttrFieldValue,outMap))
//      }
//    }
//
//    resultList
//  }





  case class PD(policys:immutable.List[String],datas:immutable.Map[String,String])

  def main (args: Array[String]) {


//    val myMap =  scalafy(parsed).asInstanceOf[immutable.Map[String, Any]]
//    val policys=myMap.get("policys").get.asInstanceOf[immutable.List[String]]
//        val datas=myMap.get("datas").get.asInstanceOf[immutable.Map[String,String]]

    val beginTime=System.currentTimeMillis()
    val jsonParser =new JSONParser()
    val json =  mapAsScalaMap(jsonParser.parse("{\"ip\":\"192.168.6.52\",\"payamount\":\"19.8\",\"username\":\"wangqiaoshi\",\"city\":\"shanghai\",\"time\":\"1441609877451\"}").asInstanceOf[java.util.HashMap[String,String]])

//










    val endTime=System.currentTimeMillis()
//
    println("all time spend "+(endTime-beginTime))
//    parseToPolicyAndData("{\"policys\":[\"ip:payamount:avg\",\"ip:city:distinctcount\",\"username:payamount:sum\",\"username:city:distinctcount\"],\"datas\":{\"ip\":\"192.168.6.52\",\"payamount\":\"19.8\",\"username\":\"wangqiaoshi\",\"city\":\"shanghai\",\"time\":\"1441609877451\"}}")
  }


  def parseToHashMap(jsonStr: String): (String, immutable.Map[String, String]) = {


    val hashMap = JsonParser.parse(jsonStr).values.asInstanceOf[immutable.Map[String, String]]
    val groupKey = hashMap.get("username").get
    (groupKey, hashMap)
  }

  import com.alibaba.fastjson.JSON


  def fastJson( json:String): Unit ={
    val beginTime=System.currentTimeMillis()
    val pd=JSON.parse(json)
    val endTime=System.currentTimeMillis()
    println("single time is "+(endTime-beginTime))

  }

  import scala.collection.JavaConversions.mapAsScalaMap
  import scala.collection.JavaConversions.asScalaBuffer


  def smartJson(jsonData:String):mutable.MutableList[(String,mutable.Map[String,String])] ={
    val resultList=new mutable.MutableList[(String,mutable.Map[String,String])]()
    val jsonParser =new JSONParser()

    val json : JSONObject =  jsonParser.parse(jsonData).asInstanceOf[JSONObject]

    val datas=mapAsScalaMap(json.get("datas").asInstanceOf[java.util.HashMap[String,String]])
    val policys= asScalaBuffer(json.get("policys").asInstanceOf[java.util.List[String]])

    for(policy<-policys){
      val Array(priAttrFieldName,computeFieldName,computeType,outRange)=policy.split(":")

      datas.get(priAttrFieldName) match {
        case None=>

        case Some(priAttrFieldValue)=>
          val outMap=mutable.Map[String,String]()
          outMap.put("time",datas.get("time").get)
          outMap.put(computeFieldName,datas.get(computeFieldName).get)
          resultList.+=((policy+","+priAttrFieldValue,outMap))
      }
    }

    resultList
  }

  def liftJson(jsonData:String): Unit ={
    val hashMap=JsonParser.parse(jsonData).values.asInstanceOf[immutable.Map[String,Any]]


    val policys=hashMap.getOrElse("policys","[]").asInstanceOf[immutable.List[String]]
    val datas=hashMap.getOrElse("datas","{}").asInstanceOf[immutable.Map[String,String]]
  }




}

class test{
  var policys:immutable.List[String]=null
  var datas:Map[String,String]=null
  def setPolicys(policys:immutable.List[String]): Unit ={
    this.policys=policys
  }
  def setDatas(datas:immutable.Map[String,String]): Unit ={
    this.datas=datas
  }
}



